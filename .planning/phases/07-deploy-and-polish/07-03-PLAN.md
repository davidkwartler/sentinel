---
phase: 07-deploy-and-polish
plan: 03
type: execute
wave: 2
depends_on:
  - 07-02
files_modified:
  - src/app/api/session/record/__tests__/route.test.ts
autonomous: true
requirements:
  - DEPLOY-VALIDATION
# Note: Phase 7 introduces no new v1 requirement IDs. All 20 v1 requirements
# were satisfied in Phases 1-6. This plan adds route handler integration tests,
# satisfying Phase 7 Success Criterion SC-6 (route handler response shapes, auth guard behavior).

must_haves:
  truths:
    - "POST /api/session/record returns 401 when called without a valid session"
    - "POST /api/session/record returns 400 for a payload with an empty visitorId"
    - "POST /api/session/record returns 200 with {status:'duplicate'} for a repeated requestId"
    - "All three route tests pass in `npm run test:run`"
  artifacts:
    - path: "src/app/api/session/record/__tests__/route.test.ts"
      provides: "Route handler integration tests for POST /api/session/record"
      contains: "401"
  key_links:
    - from: "src/app/api/session/record/__tests__/route.test.ts"
      to: "src/app/api/session/record/route.ts"
      via: "import { POST } from '../route'"
      pattern: "import.*POST.*route"
    - from: "src/app/api/session/record/__tests__/route.test.ts"
      to: "src/lib/__mocks__/db.ts"
      via: "prismaMock"
      pattern: "prismaMock"
---

<objective>
Write route handler integration tests for `POST /api/session/record` — covering the 401 unauthenticated, 400 invalid payload, and 200 duplicate-requestId response shapes.

Purpose: Phase 7 SC-6 specifies "route handler response shapes" and "auth guard behavior" as minimum test coverage. These are integration tests: they import the handler directly, mock its dependencies (auth, prisma), and assert on the HTTP response.
Output: `src/app/api/session/record/__tests__/route.test.ts` with 3 passing tests extending the suite from Plan 02.
</objective>

<execution_context>
@/Users/davidkwartler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidkwartler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/07-deploy-and-polish/07-02-SUMMARY.md
@.planning/phases/07-deploy-and-polish/07-RESEARCH.md

<interfaces>
<!-- Key types and contracts for the route handler and its dependencies. -->

From src/app/api/session/record/route.ts (full handler — executor must read this file):
```typescript
export async function POST(request: NextRequest): Promise<NextResponse>
// Auth check: const session = await auth(); if (!session?.user) return 401
// DB lookup: prisma.session.findFirst({ where: { userId: session.user.id } })
//            if not found → 404
// Body parse: fingerprintSchema.safeParse(body); if invalid → 400
// Dedup check: prisma.fingerprint.findUnique({ where: { requestId } })
//              if exists → 200 { status: 'duplicate', id: existing.id }
// ... (fingerprint create, detection, claude dispatch)
// Happy path → 200 { status: 'ok', id, detected, eventId }
```

Zod schema used by the route (from src/app/api/session/record/route.ts):
```typescript
const fingerprintSchema = z.object({
  visitorId: z.string().min(1),   // empty string fails validation
  requestId: z.string().min(1),
  os: z.string().optional(),
  browser: z.string().optional(),
  screenRes: z.string().optional(),
  timezone: z.string().optional(),
  modelOverride: z.string().optional(),
})
```

Module paths to mock:
- '@/lib/auth' → exports: { auth }
- '@/lib/db' → exports: { prisma } (already mocked via src/lib/__mocks__/db.ts)
- '@/lib/detection' → exports: { runDetection }
- '@/lib/claude' → exports: { analyzeDetectionEvent }
- 'next/server' → NextRequest is real (not mocked), but 'after' must be mocked

Auth return types:
```typescript
// Unauthenticated: auth() returns null
vi.mocked(auth).mockResolvedValue(null)

// Authenticated: auth() returns a Session object with user.id
vi.mocked(auth).mockResolvedValue({ user: { id: 'user-1' } } as any)
```

Note on 'after' from next/server: The route uses `after(async () => {...})` for async Claude
dispatch. In tests this must be mocked to avoid the runtime error "after() must be called in a
Next.js context". Mock it as a no-op:
```typescript
vi.mock('next/server', async (importOriginal) => {
  const actual = await importOriginal<typeof import('next/server')>()
  return { ...actual, after: vi.fn() }
})
```

Note on vitest-mock-extended and $transaction for duplicate test:
The duplicate test path does NOT reach $transaction (it returns before runDetection).
Mock `prisma.fingerprint.findUnique` to return a non-null value:
```typescript
prismaMock.fingerprint.findUnique.mockResolvedValue({
  id: 'fp-existing', ...
})
```

prismaMock is imported from src/lib/__mocks__/db.ts (established in Plan 02).
The vi.mock('@/lib/db') call inside __mocks__/db.ts auto-hoists — importing prismaMock
from that file is sufficient; no need to call vi.mock('@/lib/db') again in this test file.
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Write route handler integration tests (401, 400, 200-duplicate)</name>
  <files>src/app/api/session/record/__tests__/route.test.ts</files>
  <behavior>
    - Test 1 (auth guard): POST with auth() returning null → response.status === 401
    - Test 2 (validation): POST with auth() returning a user but visitorId = '' → response.status === 400
    - Test 3 (deduplication): POST with valid payload but requestId already in DB → response.status === 200, body.status === 'duplicate'
    - All three tests use mocked auth and mocked Prisma (never hit real DB)
    - 'after' from next/server is mocked as a no-op (avoid Next.js context requirement)
  </behavior>
  <action>
    Create the directory if it doesn't exist:
    ```bash
    mkdir -p /Users/davidkwartler/sentinel/src/app/api/session/record/__tests__
    ```

    Create `src/app/api/session/record/__tests__/route.test.ts`:

    ```typescript
    // src/app/api/session/record/__tests__/route.test.ts
    // Integration tests for POST /api/session/record
    // Tests mock auth, prisma, and detection — no real DB or network calls.

    import { describe, it, expect, vi, beforeEach } from 'vitest'
    import { NextRequest } from 'next/server'

    // Mock next/server 'after' to avoid "after() must be called in a Next.js context" error.
    // Must be declared before importing the route handler.
    vi.mock('next/server', async (importOriginal) => {
      const actual = await importOriginal<typeof import('next/server')>()
      return { ...actual, after: vi.fn() }
    })

    // Mock auth module
    vi.mock('@/lib/auth', () => ({ auth: vi.fn() }))

    // Mock detection and claude (avoid side effects in integration tests)
    vi.mock('@/lib/detection', () => ({ runDetection: vi.fn().mockResolvedValue({ detected: false }) }))
    vi.mock('@/lib/claude', () => ({ analyzeDetectionEvent: vi.fn() }))

    // prismaMock import triggers vi.mock('@/lib/db') via the __mocks__/db.ts auto-hoist
    import { prismaMock } from '@/lib/__mocks__/db'
    import { POST } from '../route'
    import { auth } from '@/lib/auth'

    function makeRequest(body: unknown): NextRequest {
      return new NextRequest('http://localhost/api/session/record', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })
    }

    describe('POST /api/session/record', () => {
      beforeEach(() => {
        vi.clearAllMocks()
      })

      it('returns 401 when unauthenticated (auth() returns null)', async () => {
        vi.mocked(auth).mockResolvedValue(null)

        const request = makeRequest({ visitorId: 'fp-1', requestId: 'req-1' })
        const response = await POST(request)

        expect(response.status).toBe(401)
        const body = await response.json()
        expect(body.error).toBe('Unauthorized')
      })

      it('returns 400 for invalid payload (empty visitorId)', async () => {
        vi.mocked(auth).mockResolvedValue({ user: { id: 'user-1' }, expires: '' } as any)
        // Session found in DB so the route proceeds to body validation
        prismaMock.session.findFirst.mockResolvedValue({
          id: 'sess-1',
          sessionToken: 'tok',
          userId: 'user-1',
          expires: new Date(Date.now() + 3600000),
        })

        const request = makeRequest({ visitorId: '', requestId: 'req-1' })
        const response = await POST(request)

        expect(response.status).toBe(400)
        const body = await response.json()
        expect(body.error).toBe('Invalid payload')
      })

      it('returns 200 with status:duplicate when requestId already exists', async () => {
        vi.mocked(auth).mockResolvedValue({ user: { id: 'user-1' }, expires: '' } as any)
        prismaMock.session.findFirst.mockResolvedValue({
          id: 'sess-1',
          sessionToken: 'tok',
          userId: 'user-1',
          expires: new Date(Date.now() + 3600000),
        })
        prismaMock.fingerprint.findUnique.mockResolvedValue({
          id: 'fp-existing',
          sessionId: 'sess-1',
          visitorId: 'fp-original',
          requestId: 'req-1',
          ip: null,
          userAgent: null,
          os: null,
          browser: null,
          screenRes: null,
          timezone: null,
          isOriginal: true,
          createdAt: new Date(),
        })

        const request = makeRequest({ visitorId: 'fp-1', requestId: 'req-1' })
        const response = await POST(request)

        expect(response.status).toBe(200)
        const body = await response.json()
        expect(body.status).toBe('duplicate')
        expect(body.id).toBe('fp-existing')
      })
    })
    ```

    After writing the file, run the full test suite:
    ```bash
    cd /Users/davidkwartler/sentinel && npm run test:run 2>&1
    ```

    Expected: 12 passing tests (9 from Plan 02 + 3 new route tests), 0 failures.

    If the NextRequest constructor fails (Next.js requires a full URL), ensure the URL in
    makeRequest is fully qualified (it is: 'http://localhost/...').

    If the route handler cannot be imported (Next.js module resolution issue), add this to
    vitest.config.mts under `test`:
    ```typescript
    alias: {
      'next/server': 'next/dist/server/web/exports/index.js'
    }
    ```
    Only add this alias if the import fails — it's a fallback, not required by default.
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npm run test:run 2>&1</automated>
  </verify>
  <done>
    `npm run test:run` exits with code 0. Total tests: at least 12 passing (9 detection + 3 route).
    The output shows "POST /api/session/record" describe block with all 3 tests passing.
    Zero failures.
  </done>
</task>

</tasks>

<verification>
- `npm run test:run` passes all tests (detection suite + route handler suite)
- The 401 test confirms the auth guard works
- The 400 test confirms Zod validation rejects empty visitorId
- The 200-duplicate test confirms deduplication path returns correct response shape
- No real HTTP requests or database connections in any test
</verification>

<success_criteria>
1. `npm run test:run` exits 0 with 12+ passing tests total
2. `src/app/api/session/record/__tests__/route.test.ts` exists with 3 tests
3. All tests use mocked dependencies — no real Neon database connections
</success_criteria>

<output>
After completion, create `.planning/phases/07-deploy-and-polish/07-03-SUMMARY.md` with:
- Total test count after Plan 03 (Plan 02 tests + new route tests)
- Any issues with Next.js module mocking (after(), NextRequest) and their resolutions
- Confirmation that the test suite passes in CI-equivalent mode (`vitest run`)
</output>
