---
phase: 07-deploy-and-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.mts
  - package.json
  - src/test/setup.ts
  - src/lib/__mocks__/db.ts
  - src/lib/__tests__/detection.test.ts
autonomous: true
requirements:
  - DEPLOY-VALIDATION
# Note: Phase 7 introduces no new v1 requirement IDs. All 20 v1 requirements
# were satisfied in Phases 1-6. This plan validates existing behavior (computeSimilarity,
# runDetection) with automated tests, satisfying Phase 7 Success Criterion SC-6.

must_haves:
  truths:
    - "vitest is installed and `npm run test:run` executes without crashing"
    - "computeSimilarity unit tests cover: all-match, no-match, both-null=match, one-side-null=inconclusive, case-insensitive"
    - "runDetection tests cover: no-original returns detected:false, matching visitorId returns detected:false, mismatch creates DetectionEvent returns detected:true"
    - "All tests pass (green) on the first run after implementation"
  artifacts:
    - path: "vitest.config.mts"
      provides: "Vitest configuration with tsconfigPaths and react plugins"
      contains: "tsconfigPaths"
    - path: "src/lib/__mocks__/db.ts"
      provides: "Deep Prisma mock singleton reused across all test files"
      contains: "mockDeep"
    - path: "src/lib/__tests__/detection.test.ts"
      provides: "computeSimilarity and runDetection test suite"
      contains: "computeSimilarity"
    - path: "src/test/setup.ts"
      provides: "Global Vitest setup file"
  key_links:
    - from: "src/lib/__tests__/detection.test.ts"
      to: "src/lib/detection.ts"
      via: "import { computeSimilarity, runDetection }"
      pattern: "import.*detection"
    - from: "src/lib/__tests__/detection.test.ts"
      to: "src/lib/__mocks__/db.ts"
      via: "prismaMock import"
      pattern: "import.*prismaMock"
    - from: "vitest.config.mts"
      to: "src/test/setup.ts"
      via: "setupFiles"
      pattern: "setupFiles"
---

<objective>
Install Vitest test infrastructure from scratch and write the computeSimilarity and runDetection unit tests with a mocked Prisma client.

Purpose: Phase 7 SC-6 requires "unit and integration tests across the project — at minimum: computeSimilarity edge cases, runDetection transaction logic (mocked DB)." This plan establishes the test infrastructure and covers both detection library functions.
Output: vitest.config.mts, package.json test scripts, Prisma mock singleton, and a passing detection.test.ts with 8 test cases.
</objective>

<execution_context>
@/Users/davidkwartler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidkwartler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/07-deploy-and-polish/07-RESEARCH.md

<interfaces>
<!-- Key types the executor needs. Extracted from codebase. -->

From src/lib/detection.ts:
```typescript
interface FingerprintComponents {
  os?: string | null
  browser?: string | null
  screenRes?: string | null
  timezone?: string | null
}

export function computeSimilarity(
  a: FingerprintComponents,
  b: FingerprintComponents
): number
// Each of 4 fields contributes 0.25 if matched.
// Both-null = match (0.25 contributed). One-side-null = inconclusive (0 contributed).
// Compares via: a[field]?.toLowerCase().trim() || null

export interface DetectionInput {
  sessionId: string
  newVisitorId: string
  newIp: string | null
  os?: string | null
  browser?: string | null
  screenRes?: string | null
  timezone?: string | null
}

export interface DetectionResult {
  detected: boolean
  eventId?: string
}

export async function runDetection(params: DetectionInput): Promise<DetectionResult>
// Uses prisma.$transaction(async (tx) => { ... })
// Inside transaction: tx.fingerprint.findFirst({ where: { sessionId, isOriginal: true } })
// If no original → { detected: false }
// If same visitorId → { detected: false }
// If different visitorId → tx.detectionEvent.create({...}) → { detected: true, eventId: event.id }
```

From src/lib/db.ts:
```typescript
// Module path: @/lib/db
export const prisma: InstanceType<typeof PrismaClient>
// Uses custom PrismaClient from @/generated/prisma/client
```

From prisma/schema.prisma (Fingerprint model — needed for mock return values):
```
id, sessionId, visitorId, requestId, ip, userAgent, os, browser, screenRes, timezone,
isOriginal (Boolean), createdAt (DateTime)
```

From prisma/schema.prisma (DetectionEvent model — needed for mock return values):
```
id, createdAt, sessionId, originalVisitorId, newVisitorId, originalIp, newIp,
similarityScore (Float), status (String), confidenceScore (Float?), reasoning (String?)
```

Prisma client import path: `import type { PrismaClient } from '@/generated/prisma/client'`
(NOT from '@prisma/client' — the project uses output = "../src/generated/prisma")

$transaction mock pattern (critical — without this, tx.fingerprint.findFirst is never called):
```typescript
prismaMock.$transaction.mockImplementation(async (fn) => fn(prismaMock))
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Install Vitest and create test infrastructure</name>
  <files>
    vitest.config.mts
    package.json
    src/test/setup.ts
    src/lib/__mocks__/db.ts
  </files>
  <behavior>
    - vitest.config.mts loads with tsconfigPaths() so @/ imports resolve correctly in tests
    - vitest.config.mts uses environment: 'jsdom' and globals: true
    - vitest.config.mts references src/test/setup.ts as setupFiles
    - package.json has "test": "vitest" and "test:run": "vitest run" scripts
    - src/lib/__mocks__/db.ts exports prismaMock as DeepMockProxy&lt;PrismaClient&gt;
    - prismaMock resets before each test (mockReset in beforeEach)
    - vi.mock('@/lib/db') is called so runDetection picks up the mock automatically
  </behavior>
  <action>
    Step 1 — Install test dependencies:
    ```bash
    cd /Users/davidkwartler/sentinel && npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths vitest-mock-extended
    ```

    Step 2 — Create vitest.config.mts at project root:
    ```typescript
    // vitest.config.mts
    import { defineConfig } from 'vitest/config'
    import react from '@vitejs/plugin-react'
    import tsconfigPaths from 'vite-tsconfig-paths'

    export default defineConfig({
      plugins: [tsconfigPaths(), react()],
      test: {
        environment: 'jsdom',
        globals: true,
        setupFiles: ['./src/test/setup.ts'],
      },
    })
    ```

    Step 3 — Create src/test/setup.ts (global setup — currently empty but required by config):
    ```typescript
    // src/test/setup.ts
    // Global Vitest setup. Add @testing-library/jest-dom or other global matchers here.
    ```

    Step 4 — Create src/lib/__mocks__/db.ts (Prisma mock singleton):
    ```typescript
    // src/lib/__mocks__/db.ts
    // Provides a deep mock of the Prisma client for unit tests.
    // Import prismaMock in test files to set up mock return values.
    // vi.mock('@/lib/db') must be called in each test file that imports code using prisma.
    import { vi, beforeEach } from 'vitest'
    import { mockDeep, mockReset, DeepMockProxy } from 'vitest-mock-extended'
    import type { PrismaClient } from '@/generated/prisma/client'

    vi.mock('@/lib/db', () => ({
      prisma: mockDeep<PrismaClient>(),
    }))

    import { prisma } from '@/lib/db'

    export const prismaMock = prisma as unknown as DeepMockProxy<PrismaClient>

    beforeEach(() => {
      mockReset(prismaMock)
    })
    ```

    Step 5 — Add test scripts to package.json. Add to the "scripts" section:
    ```json
    "test": "vitest",
    "test:run": "vitest run"
    ```
    (Keep all existing scripts intact — only add these two new ones.)

    Step 6 — Verify the infrastructure is wired correctly before writing tests:
    ```bash
    cd /Users/davidkwartler/sentinel && npm run test:run -- --reporter=verbose 2>&1 | head -20
    ```
    Expected: "No test files found" (not a crash/config error). A config error would show
    "Failed to load" or "Cannot find module" messages. Fix any such errors before proceeding.
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npm run test:run 2>&1 | tail -10</automated>
  </verify>
  <done>
    `npm run test:run` exits without a config/import error. The output says "No test files found"
    or similar — not a crash. vitest.config.mts exists at project root. src/lib/__mocks__/db.ts
    exports prismaMock. package.json has "test:run": "vitest run" script.
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Write computeSimilarity and runDetection unit tests</name>
  <files>src/lib/__tests__/detection.test.ts</files>
  <behavior>
    computeSimilarity tests (pure function — no mocks needed):
    - Test 1: all four fields match → returns 1.0
    - Test 2: all four fields differ → returns 0.0
    - Test 3: both sides null for a field → treated as match (0.25 contributed per null-null pair)
    - Test 4: one side null, other has value → inconclusive (0 contributed for that field)
    - Test 5: strings with different casing/whitespace → treated as equal (lowercased + trimmed)
    - Test 6: only 2 of 4 fields match → returns 0.5

    runDetection tests (requires prismaMock — $transaction must be mocked):
    - Test 7: no original fingerprint exists (findFirst returns null) → { detected: false }
    - Test 8: original exists and visitorId matches → { detected: false }
    - Test 9: original exists and visitorId differs → { detected: true, eventId: 'event-1' }
             + detectionEvent.create called exactly once
  </behavior>
  <action>
    Create src/lib/__tests__/detection.test.ts.

    IMPORTANT: `vi.mock('@/lib/db')` must appear before any import of the detection module —
    Vitest hoists vi.mock calls automatically, but the import of prismaMock from __mocks__/db.ts
    handles this. Use the import path `'../  __mocks__/db'` to pull prismaMock into the test.

    ```typescript
    // src/lib/__tests__/detection.test.ts
    import { describe, it, expect } from 'vitest'
    import { prismaMock } from '../__mocks__/db'
    import { computeSimilarity, runDetection } from '../detection'

    describe('computeSimilarity', () => {
      it('returns 1.0 when all four components match', () => {
        const result = computeSimilarity(
          { os: 'Mac OS', browser: 'Chrome', screenRes: '1920x1080', timezone: 'America/New_York' },
          { os: 'Mac OS', browser: 'Chrome', screenRes: '1920x1080', timezone: 'America/New_York' }
        )
        expect(result).toBeCloseTo(1.0)
      })

      it('returns 0.0 when all four components differ', () => {
        const result = computeSimilarity(
          { os: 'Mac OS', browser: 'Chrome', screenRes: '1920x1080', timezone: 'America/New_York' },
          { os: 'Windows', browser: 'Firefox', screenRes: '1366x768', timezone: 'Europe/London' }
        )
        expect(result).toBeCloseTo(0.0)
      })

      it('treats both-null as a match (contributes 0.25 per null-null field)', () => {
        // All 4 fields null on both sides = 4 matches = 1.0
        const result = computeSimilarity({}, {})
        expect(result).toBeCloseTo(1.0)
      })

      it('treats one-side-null as inconclusive (no bonus, no penalty)', () => {
        // os matches (0.25), browser/screenRes/timezone are one-side-null (inconclusive = 0)
        const result = computeSimilarity(
          { os: 'Mac OS', browser: null, screenRes: null, timezone: null },
          { os: 'Mac OS', browser: 'Chrome', screenRes: '1920x1080', timezone: 'America/New_York' }
        )
        expect(result).toBeCloseTo(0.25)
      })

      it('is case-insensitive and trims whitespace', () => {
        const result = computeSimilarity(
          { os: '  Mac OS  ' },
          { os: 'mac os' }
        )
        // os matches (0.25), all other fields absent on both sides = null-null = match (0.75)
        // Total = 1.0
        expect(result).toBeCloseTo(1.0)
      })

      it('returns 0.5 for exactly two matching fields out of four', () => {
        const result = computeSimilarity(
          { os: 'Mac OS', browser: 'Chrome', screenRes: '1920x1080', timezone: 'UTC' },
          { os: 'Mac OS', browser: 'Chrome', screenRes: '1366x768', timezone: 'Europe/London' }
        )
        expect(result).toBeCloseTo(0.5)
      })
    })

    describe('runDetection', () => {
      it('returns detected:false when no original fingerprint exists', async () => {
        prismaMock.$transaction.mockImplementation(async (fn: (tx: typeof prismaMock) => unknown) => fn(prismaMock))
        prismaMock.fingerprint.findFirst.mockResolvedValue(null)

        const result = await runDetection({
          sessionId: 'sess-1',
          newVisitorId: 'fp-new',
          newIp: '1.2.3.4',
        })
        expect(result.detected).toBe(false)
      })

      it('returns detected:false when visitorId matches original', async () => {
        prismaMock.$transaction.mockImplementation(async (fn: (tx: typeof prismaMock) => unknown) => fn(prismaMock))
        prismaMock.fingerprint.findFirst.mockResolvedValue({
          id: 'fp-1',
          visitorId: 'fp-same',
          sessionId: 'sess-1',
          requestId: 'req-1',
          ip: '1.2.3.4',
          userAgent: null,
          os: null,
          browser: null,
          screenRes: null,
          timezone: null,
          isOriginal: true,
          createdAt: new Date(),
        })

        const result = await runDetection({
          sessionId: 'sess-1',
          newVisitorId: 'fp-same',
          newIp: '1.2.3.4',
        })
        expect(result.detected).toBe(false)
      })

      it('returns detected:true and creates DetectionEvent on visitorId mismatch', async () => {
        prismaMock.$transaction.mockImplementation(async (fn: (tx: typeof prismaMock) => unknown) => fn(prismaMock))
        prismaMock.fingerprint.findFirst.mockResolvedValue({
          id: 'fp-1',
          visitorId: 'fp-original',
          sessionId: 'sess-1',
          requestId: 'req-1',
          ip: '1.2.3.4',
          userAgent: null,
          os: 'Mac OS',
          browser: 'Chrome',
          screenRes: '1920x1080',
          timezone: 'America/New_York',
          isOriginal: true,
          createdAt: new Date(),
        })
        prismaMock.detectionEvent.create.mockResolvedValue({
          id: 'event-1',
          createdAt: new Date(),
          sessionId: 'sess-1',
          originalVisitorId: 'fp-original',
          newVisitorId: 'fp-new',
          originalIp: '1.2.3.4',
          newIp: '9.9.9.9',
          similarityScore: 0.0,
          status: 'PENDING',
          confidenceScore: null,
          reasoning: null,
        })

        const result = await runDetection({
          sessionId: 'sess-1',
          newVisitorId: 'fp-new',
          newIp: '9.9.9.9',
          os: 'Windows',
          browser: 'Firefox',
          screenRes: '1366x768',
          timezone: 'Europe/London',
        })

        expect(result.detected).toBe(true)
        expect(result.eventId).toBe('event-1')
        expect(prismaMock.detectionEvent.create).toHaveBeenCalledOnce()
      })
    })
    ```

    After writing the file, run tests in RED phase first to confirm they fail with the right errors
    (i.e., test assertions failing, not import errors). Then verify they pass GREEN.

    If TypeScript complains about the $transaction mock fn parameter type, cast it:
    ```typescript
    prismaMock.$transaction.mockImplementation(async (fn: any) => fn(prismaMock))
    ```
    The `any` cast here is acceptable — the mock infrastructure doesn't need strict typing on
    the callback parameter.
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npm run test:run 2>&1</automated>
  </verify>
  <done>
    `npm run test:run` exits with code 0. Output shows 9 tests pass across 2 test suites
    (computeSimilarity: 6 tests, runDetection: 3 tests). Zero failures, zero skips.
  </done>
</task>

</tasks>

<verification>
- `npm install` completes without peer dependency errors
- `npm run test:run` runs and all 9 tests pass
- No test uses a real database connection (all Prisma calls go through prismaMock)
- vitest.config.mts exists with tsconfigPaths plugin (confirmed @/ alias works in tests)
- src/lib/__mocks__/db.ts exports prismaMock with beforeEach mockReset
</verification>

<success_criteria>
1. `npm run test:run` exits 0 with 9 passing tests (6 computeSimilarity + 3 runDetection)
2. Test infrastructure files created: vitest.config.mts, src/test/setup.ts, src/lib/__mocks__/db.ts
3. No test touches the real Neon database
4. package.json has "test:run": "vitest run" script
</success_criteria>

<output>
After completion, create `.planning/phases/07-deploy-and-polish/07-02-SUMMARY.md` with:
- List of installed test packages and versions
- Test results summary (N passing, N failing)
- Any issues encountered with the $transaction mock or type errors, and how they were resolved
</output>
