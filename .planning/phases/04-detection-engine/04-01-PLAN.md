---
phase: 04-detection-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/detection.ts
autonomous: true
requirements:
  - DETECT-02
  - DETECT-03

must_haves:
  truths:
    - "The DetectionEvent table exists in Neon with all required columns (id, createdAt, sessionId, originalVisitorId, newVisitorId, originalIp, newIp, similarityScore, status)"
    - "The Prisma client is regenerated and detectionEvent is a typed accessor on PrismaClient"
    - "computeSimilarity returns 1.0 when all four components match, 0.0 when none match, and proportional values for partial matches"
    - "runDetection returns { detected: false } when no original fingerprint exists for the session"
    - "runDetection returns { detected: false } when the incoming visitorId matches the original"
    - "runDetection returns { detected: true, eventId: string } and writes a DetectionEvent row when visitorIds differ"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "DetectionEvent model + Session.detectionEvents reverse relation"
      contains: "model DetectionEvent"
    - path: "src/lib/detection.ts"
      provides: "computeSimilarity function and runDetection async function"
      exports: ["computeSimilarity", "runDetection"]
  key_links:
    - from: "src/lib/detection.ts"
      to: "prisma.$transaction"
      via: "runDetection wraps read + conditional insert in $transaction"
      pattern: "prisma\\.\\$transaction"
    - from: "prisma/schema.prisma"
      to: "src/generated/prisma"
      via: "npx prisma db push && npx prisma generate"
      pattern: "DetectionEvent"
---

<objective>
Add the DetectionEvent Prisma model to the schema, push it to Neon, regenerate the TypeScript client, and implement the detection library (similarity scoring + transaction-wrapped detection logic) that the route handler will call in Plan 02.

Purpose: This plan establishes the data model and all pure logic for fingerprint mismatch detection. All code here is testable in isolation — the route handler wiring is separate (Plan 02).
Output: prisma/schema.prisma (updated), src/generated/prisma (regenerated), src/lib/detection.ts (new)
</objective>

<execution_context>
@/Users/davidkwartler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidkwartler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-detection-engine/04-RESEARCH.md
@prisma/schema.prisma
@src/lib/db.ts

<interfaces>
<!-- Key types the executor needs. Extracted from codebase. -->

From prisma/schema.prisma (existing models — DO NOT remove or alter):
```prisma
model Session {
  id           String        @id @default(cuid())
  sessionToken String        @unique
  userId       String
  expires      DateTime
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  fingerprints Fingerprint[]
  // ADD: detectionEvents DetectionEvent[]
}

model Fingerprint {
  id         String   @id @default(cuid())
  sessionId  String
  visitorId  String
  requestId  String   @unique
  ip         String?
  userAgent  String?  @db.Text
  os         String?
  browser    String?
  screenRes  String?
  timezone   String?
  isOriginal Boolean  @default(false)
  createdAt  DateTime @default(now())
  session    Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  @@index([sessionId])
  @@index([visitorId])
}
```

From src/lib/db.ts:
```typescript
import { PrismaClient } from "@/generated/prisma/client"
export const prisma: PrismaClient  // singleton, use this everywhere
```

Prisma import path for error types:
```typescript
import { Prisma } from "@/generated/prisma/client"
// Use: Prisma.PrismaClientKnownRequestError, e.code === "P2002"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DetectionEvent model to schema and regenerate client</name>
  <files>prisma/schema.prisma</files>
  <action>
Edit prisma/schema.prisma to make two additions:

**1. Add `detectionEvents` relation to the existing Session model** (add one line to the existing model — do not change any other field):
```prisma
model Session {
  id              String           @id @default(cuid())
  sessionToken    String           @unique
  userId          String
  expires         DateTime
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  fingerprints    Fingerprint[]
  detectionEvents DetectionEvent[]   // ADD THIS LINE
}
```

**2. Append the new DetectionEvent model** at the end of the file (after VerificationToken):
```prisma
model DetectionEvent {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  sessionId         String
  originalVisitorId String
  newVisitorId      String
  originalIp        String?
  newIp             String?
  similarityScore   Float
  status            String   @default("PENDING")
  session           Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}
```

Then run both commands in sequence — both MUST succeed before proceeding:
```bash
npx prisma db push
npx prisma generate
```

Do NOT add `export const runtime = 'edge'` anywhere in the project — Prisma requires Node.js runtime.

After `prisma generate` completes, restart the Next.js dev server so the updated generated types are loaded.
  </action>
  <verify>
    <automated>npx prisma validate && node -e "const {PrismaClient} = require('./src/generated/prisma/client.js'); const p = new PrismaClient(); console.log(typeof p.detectionEvent)"</automated>
  </verify>
  <done>
    `npx prisma validate` exits 0 with no errors. The `detectionEvent` property exists on PrismaClient (typeof returns "object"). The DetectionEvent table exists in Neon (visible via `npx prisma studio` or direct DB query if needed).
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Implement detection.ts — similarity function and runDetection</name>
  <files>src/lib/detection.ts</files>
  <behavior>
    - computeSimilarity({os:"mac",browser:"chrome",screenRes:"1920x1080",timezone:"UTC"}, same) → 1.0
    - computeSimilarity({os:"mac",browser:"chrome",screenRes:"1920x1080",timezone:"UTC"}, {os:"windows",browser:"firefox",screenRes:"1366x768",timezone:"America/New_York"}) → 0.0
    - computeSimilarity({os:"mac",browser:"chrome",screenRes:null,timezone:null}, {os:"mac",browser:"firefox",screenRes:null,timezone:null}) → 0.75 (os matches=0.25, browser miss=0, both-null screenRes=0.25, both-null timezone=0.25)
    - computeSimilarity({os:null,browser:null,screenRes:null,timezone:null}, {os:null,browser:null,screenRes:null,timezone:null}) → 1.0 (all both-null = match)
    - computeSimilarity({os:"mac",browser:null,screenRes:"1920x1080",timezone:"UTC"}, {os:"mac",browser:"chrome",screenRes:"1920x1080",timezone:"UTC"}) → 0.75 (one side missing browser = no bonus)
    - runDetection with no original fingerprint for session → { detected: false }
    - runDetection with same visitorId as original → { detected: false }, no DetectionEvent row created
    - runDetection with different visitorId → { detected: true, eventId: string }, DetectionEvent row exists with correct fields
  </behavior>
  <action>
Create src/lib/detection.ts with the following exports. This file must NOT import from route handlers or Next.js — only from @/lib/db and @/generated/prisma/client.

```typescript
import { prisma } from "@/lib/db"

interface FingerprintComponents {
  os?: string | null
  browser?: string | null
  screenRes?: string | null
  timezone?: string | null
}

/**
 * Compute similarity score between two fingerprint component sets.
 * Each of 4 components contributes 0.25 to the score if they match.
 * Both-null is treated as a match (unknown ≠ mismatch).
 * One-side-null is treated as inconclusive (no bonus, no penalty).
 * Returns 0.0–1.0 float. 1.0 = identical, 0.0 = completely different.
 */
export function computeSimilarity(
  a: FingerprintComponents,
  b: FingerprintComponents
): number {
  const fields: (keyof FingerprintComponents)[] = ["os", "browser", "screenRes", "timezone"]
  const weight = 1 / fields.length

  return fields.reduce((score, field) => {
    const aVal = a[field]?.toLowerCase().trim() || null
    const bVal = b[field]?.toLowerCase().trim() || null
    if (aVal === null && bVal === null) return score + weight  // both absent = match
    if (aVal === null || bVal === null) return score           // one missing = inconclusive
    return aVal === bVal ? score + weight : score
  }, 0)
}

export interface DetectionInput {
  sessionId: string
  newVisitorId: string
  newIp: string | null
  os?: string | null
  browser?: string | null
  screenRes?: string | null
  timezone?: string | null
}

export interface DetectionResult {
  detected: boolean
  eventId?: string
}

/**
 * Check whether the incoming fingerprint represents a session hijack.
 * Runs inside a Prisma $transaction for atomicity.
 * MUST be called AFTER the new fingerprint is already persisted (so isOriginal=true row exists).
 * Returns { detected: false } if no original exists or visitorIds match.
 * Returns { detected: true, eventId } and writes a DetectionEvent on mismatch.
 */
export async function runDetection(params: DetectionInput): Promise<DetectionResult> {
  const { sessionId, newVisitorId, newIp } = params

  return await prisma.$transaction(async (tx) => {
    // Read the original fingerprint for this session
    const original = await tx.fingerprint.findFirst({
      where: { sessionId, isOriginal: true },
    })

    // No original yet — first fingerprint is being established, not a hijack
    if (!original) return { detected: false }

    // Same visitorId — legitimate repeat from same browser, no event
    if (original.visitorId === newVisitorId) return { detected: false }

    // Different visitorId — compute similarity and persist detection event
    const score = computeSimilarity(original, {
      os: params.os ?? null,
      browser: params.browser ?? null,
      screenRes: params.screenRes ?? null,
      timezone: params.timezone ?? null,
    })

    const event = await tx.detectionEvent.create({
      data: {
        sessionId,
        originalVisitorId: original.visitorId,
        newVisitorId,
        originalIp: original.ip,
        newIp,
        similarityScore: score,
        status: "PENDING",
      },
    })

    return { detected: true, eventId: event.id }
  })
}
```

After writing the file, verify TypeScript compiles with no errors:
```bash
npx tsc --noEmit
```
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
  </verify>
  <done>
    src/lib/detection.ts exists. `npx tsc --noEmit` exits 0 with no type errors. Both `computeSimilarity` and `runDetection` are exported. The function signatures match the DetectionInput/DetectionResult interfaces defined in the file.
  </done>
</task>

</tasks>

<verification>
Run both checks after tasks complete:
1. `npx prisma validate` — schema is valid
2. `npx tsc --noEmit` — no TypeScript errors across the entire project
3. Confirm `src/generated/prisma/client.ts` (or index.ts) references `DetectionEvent` — grep: `grep -r "DetectionEvent" src/generated/` should produce results
</verification>

<success_criteria>
- DetectionEvent model is in prisma/schema.prisma with all 10 fields per DETECT-03: id, createdAt, sessionId, originalVisitorId, newVisitorId, originalIp, newIp, similarityScore, status, session relation
- Session model has `detectionEvents DetectionEvent[]` reverse relation
- `prisma db push` succeeded (table exists in Neon)
- `prisma generate` succeeded (PrismaClient has typed `detectionEvent` accessor)
- src/lib/detection.ts exports `computeSimilarity` (pure function, no DB) and `runDetection` (async, uses prisma.$transaction)
- `npx tsc --noEmit` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-detection-engine/04-01-SUMMARY.md` with:
- What was built (schema changes, new file)
- Key decisions made (equal-weight similarity, Float not Int, status as String not enum)
- Actual exports from detection.ts (function signatures)
- Any deviations from the plan
</output>
