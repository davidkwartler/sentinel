---
phase: 04-detection-engine
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - src/app/api/session/record/route.ts
autonomous: false
requirements:
  - DETECT-01

must_haves:
  truths:
    - "A second distinct visitorId on the same session causes a detection_events row to appear in the database"
    - "The detection event contains sessionId, originalVisitorId, newVisitorId, originalIp, newIp, similarityScore, and status=PENDING"
    - "A repeat request from the same browser (same visitorId, different requestId) does NOT create a detection event"
    - "The route handler returns detected:true and a non-null eventId in the response body when a mismatch is detected"
    - "Duplicate requestId path still returns early — runDetection is never called on a duplicate"
  artifacts:
    - path: "src/app/api/session/record/route.ts"
      provides: "Extended route handler that calls runDetection after fingerprint creation"
      contains: "runDetection"
  key_links:
    - from: "src/app/api/session/record/route.ts"
      to: "src/lib/detection.ts"
      via: "import { runDetection } from '@/lib/detection'"
      pattern: "runDetection"
    - from: "runDetection"
      to: "prisma.detectionEvent"
      via: "prisma.$transaction inside detection.ts"
      pattern: "detectionEvent\\.create"
---

<objective>
Wire the detection library into the existing fingerprint ingest route handler, and verify the end-to-end hijack simulation produces a detection event row in the database.

Purpose: This is the integration step — detection.ts is already built and tested; this plan connects it to the live ingest path so that a real session hijack simulation produces a persisted detection event.
Output: src/app/api/session/record/route.ts (modified to call runDetection and return detection metadata)
</objective>

<execution_context>
@/Users/davidkwartler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidkwartler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-detection-engine/04-RESEARCH.md
@.planning/phases/04-detection-engine/04-01-SUMMARY.md
@src/app/api/session/record/route.ts
@src/lib/detection.ts

<interfaces>
<!-- Key contracts the executor needs. -->

From src/lib/detection.ts (built in Plan 01):
```typescript
export interface DetectionInput {
  sessionId: string
  newVisitorId: string
  newIp: string | null
  os?: string | null
  browser?: string | null
  screenRes?: string | null
  timezone?: string | null
}

export interface DetectionResult {
  detected: boolean
  eventId?: string
}

export async function runDetection(params: DetectionInput): Promise<DetectionResult>
```

Current route handler response (to be extended):
```typescript
// Before: returns only { status: "ok", id: fingerprint.id }
// After:  returns { status: "ok", id: fingerprint.id, detected: boolean, eventId: string | null }
```

CRITICAL: runDetection must NOT be called on the duplicate path (early return before fingerprint.create).
CRITICAL: Do NOT add `export const runtime = 'edge'` — Prisma requires Node.js runtime.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend record route to call runDetection after fingerprint creation</name>
  <files>src/app/api/session/record/route.ts</files>
  <action>
Modify src/app/api/session/record/route.ts to import and call `runDetection` after the fingerprint is successfully created.

**Exact changes:**

1. Add import at the top (after existing imports):
```typescript
import { runDetection } from "@/lib/detection"
```

2. After the `fingerprint.create` call succeeds, add the detection call and update the return statement. The full block from fingerprint.create through the return should become:

```typescript
  const fingerprint = await prisma.fingerprint.create({
    data: {
      sessionId: dbSession.id,
      visitorId: data.visitorId,
      requestId: data.requestId,
      ip,
      userAgent,
      os: data.os ?? null,
      browser: data.browser ?? null,
      screenRes: data.screenRes ?? null,
      timezone: data.timezone ?? null,
      isOriginal: !hasExisting,
    },
  })

  // Run detection: compare new fingerprint against session's original
  // Only runs on non-duplicate, non-first fingerprints (first = isOriginal: true)
  const detectionResult = await runDetection({
    sessionId: dbSession.id,
    newVisitorId: data.visitorId,
    newIp: ip,
    os: data.os ?? null,
    browser: data.browser ?? null,
    screenRes: data.screenRes ?? null,
    timezone: data.timezone ?? null,
  })

  return NextResponse.json({
    status: "ok",
    id: fingerprint.id,
    detected: detectionResult.detected,
    eventId: detectionResult.eventId ?? null,
  })
```

The duplicate-requestId early-return path (the `if (existing)` block) must remain unchanged — `runDetection` is NOT called there.

After editing, verify TypeScript compiles:
```bash
npx tsc --noEmit
```
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
  </verify>
  <done>
    src/app/api/session/record/route.ts imports runDetection from @/lib/detection. The response shape includes `detected` (boolean) and `eventId` (string | null). The duplicate path is unchanged (returns before runDetection). `npx tsc --noEmit` exits 0.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Simulate session hijack and verify detection event</name>
  <files>none</files>
  <action>Human verification of the complete detection pipeline end-to-end. No code changes in this task — all automation was completed in Task 1. Follow the how-to-verify steps below.</action>
  <what-built>
    The complete detection pipeline: fingerprint ingest → runDetection → DetectionEvent row in Neon.
    When a second distinct visitorId hits the same session, a detection_events row appears with PENDING status, both IPs, both visitorIds, and a similarity score.
  </what-built>
  <how-to-verify>
    **Pre-condition:** The Next.js dev server is running (`npm run dev`).

    **Step 1 — Establish a baseline session (Device A):**
    1. Open Browser A (e.g., Chrome normal window) and sign in at http://localhost:3000
    2. Navigate to http://localhost:3000/products — this triggers FingerprintReporter and POSTs to /api/session/record
    3. Open DevTools > Application > Cookies and copy the full value of the `auth_session` cookie
    4. Note: the response from /api/session/record should include `"detected": false` (first fingerprint, no original to compare against)

    **Step 2 — Simulate hijack (Device B):**
    1. Open Browser B (e.g., Firefox, or Chrome Incognito — a different browser/profile that will produce a different visitorId)
    2. Open DevTools > Application > Cookies for http://localhost:3000
    3. Create a new cookie: Name=`auth_session`, Value=(paste value from Step 1), Domain=localhost, Path=/
    4. Navigate to http://localhost:3000/products — FingerprintReporter fires and POSTs a NEW visitorId to /api/session/record with the SAME session cookie

    **Step 3 — Verify detection event:**
    1. Open http://localhost:3000/api/session/record network response in Browser B's DevTools
       - Expected: `{"status":"ok","id":"...","detected":true,"eventId":"clxxxxx..."}`
    2. Run this query in Neon console (or `npx prisma studio`):
       ```sql
       SELECT id, "sessionId", "originalVisitorId", "newVisitorId", "originalIp", "newIp", "similarityScore", status, "createdAt"
       FROM "DetectionEvent"
       ORDER BY "createdAt" DESC
       LIMIT 5;
       ```
       Expected: At least 1 row with status='PENDING' and two different visitorIds

    **Negative test (same browser, different requestId):**
    1. In Browser A, navigate away and back to /products
    2. Network tab should show /api/session/record response with `"detected": false` (same visitorId — no new detection event)

    **Fallback (if FingerprintJS Pro account inactive):**
    Use curl to simulate with synthetic visitorIds:
    ```bash
    # First POST (establishes original)
    curl -X POST http://localhost:3000/api/session/record \
      -H "Content-Type: application/json" \
      -H "Cookie: auth_session=<paste-cookie-value>" \
      -d '{"visitorId":"test-visitor-aaa","requestId":"req-001","os":"macOS","browser":"Chrome","screenRes":"1920x1080","timezone":"America/Los_Angeles"}'

    # Second POST (simulates hijacker with different visitorId)
    curl -X POST http://localhost:3000/api/session/record \
      -H "Content-Type: application/json" \
      -H "Cookie: auth_session=<paste-cookie-value>" \
      -d '{"visitorId":"test-visitor-bbb","requestId":"req-002","os":"Windows","browser":"Firefox","screenRes":"1366x768","timezone":"America/New_York"}'
    ```
    Second response should contain `"detected":true,"eventId":"..."`.
  </how-to-verify>
  <verify>Human confirms detection event row appears in Neon with correct fields and both visitorIds differ.</verify>
  <done>DetectionEvent row exists in Neon with status=PENDING, two distinct visitorIds, and similarityScore between 0.0 and 1.0. Route response included detected:true and a non-null eventId.</done>
  <resume-signal>Type "approved" if detection event appears in DB with correct fields, or describe any issues observed.</resume-signal>
</task>

</tasks>

<verification>
After human approval:
1. `npx tsc --noEmit` — zero type errors
2. `grep -n "runDetection" src/app/api/session/record/route.ts` — confirms import and call site present
3. DetectionEvent row exists in Neon with: sessionId (non-null), originalVisitorId != newVisitorId, similarityScore between 0.0 and 1.0, status = "PENDING"
4. `grep -r "runtime.*edge" src/app/api/` returns no results (Edge runtime not set)
</verification>

<success_criteria>
Phase 4 complete when ALL of the following are true:
1. Simulating a hijack (second distinct visitorId on same session) creates a DetectionEvent row in Neon — success criterion 1 from ROADMAP Phase 4
2. The DetectionEvent row contains: sessionId, originalVisitorId, newVisitorId, originalIp, newIp, similarityScore — success criterion 2
3. The similarityScore field reflects the OS/browser/timezone/screenRes comparison — success criterion 3 (DETECT-02)
4. A repeat from the same browser (same visitorId) does NOT create a detection event — success criterion 4
</success_criteria>

<output>
After completion, create `.planning/phases/04-detection-engine/04-02-SUMMARY.md` with:
- What was built (route handler changes, detection result in response)
- Simulation test results (what was observed in network tab and DB)
- Any deviations from the plan
- State of the detection pipeline for Phase 5 (Claude Integration) to build on
</output>
