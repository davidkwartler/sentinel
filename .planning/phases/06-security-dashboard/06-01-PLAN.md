---
phase: 06-security-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/SessionTable.tsx
  - src/app/(shop)/dashboard/page.tsx
  - src/app/(shop)/dashboard/PollingRefresher.tsx
  - src/app/(shop)/layout.tsx
autonomous: true
requirements:
  - DASH-01
  - DASH-02
  - DASH-03

must_haves:
  truths:
    - "Navigating to /dashboard while authenticated renders a table showing all non-expired sessions, each row displaying visitorId (truncated), IP address, user-agent, and a color-coded status badge (ACTIVE / PENDING / FLAGGED / CLEAR)"
    - "Sessions with status FLAGGED can be clicked to expand a panel showing Claude's reasoning string and numeric confidence score"
    - "The dashboard data refreshes without a full page reload — router.refresh() fires every 8 seconds via PollingRefresher"
    - "The /dashboard route is protected — the server component calls auth() + redirect('/login') if session is absent"
    - "The nav bar in the shop layout includes a Dashboard link pointing to /dashboard"
  artifacts:
    - path: "src/components/SessionTable.tsx"
      provides: "Client component rendering session rows, status badges, and expandable FLAGGED detail panels"
      contains: "use client"
    - path: "src/app/(shop)/dashboard/page.tsx"
      provides: "Async Server Component — auth check, Prisma findMany, renders SessionTable + PollingRefresher"
      contains: "prisma.session.findMany"
    - path: "src/app/(shop)/dashboard/PollingRefresher.tsx"
      provides: "Client component calling router.refresh() on 8-second interval"
      contains: "router.refresh"
    - path: "src/app/(shop)/layout.tsx"
      provides: "Nav bar updated with Dashboard link"
      contains: "/dashboard"
  key_links:
    - from: "src/app/(shop)/dashboard/page.tsx"
      to: "src/components/SessionTable.tsx"
      via: "Server Component passes sessions[] prop to <SessionTable> client component"
      pattern: "SessionTable"
    - from: "src/app/(shop)/dashboard/page.tsx"
      to: "src/app/(shop)/dashboard/PollingRefresher.tsx"
      via: "Server Component renders <PollingRefresher intervalMs={8000} /> before SessionTable"
      pattern: "PollingRefresher"
    - from: "src/components/SessionTable.tsx"
      to: "prisma.detectionEvent.status"
      via: "Status derived from detectionEvents[0]?.status ?? 'ACTIVE' — FLAGGED rows expand to show reasoning"
      pattern: "FLAGGED"
---

<objective>
Build the complete Security Dashboard UI: a server-rendered session table with status badges, an expandable reasoning panel for flagged sessions, and automatic polling — all placed inside the existing (shop) route group so it inherits the nav layout and auth gate.

Purpose: This plan delivers all three dashboard requirements (DASH-01, DASH-02, DASH-03) in one autonomous execution. The data layer already exists in full (Session, Fingerprint, DetectionEvent with confidenceScore and reasoning from Phase 5). This plan is a pure presentation layer with no schema changes.
Output: Four files — SessionTable client component, dashboard page server component, PollingRefresher client component, and an updated shop layout with a Dashboard nav link.
</objective>

<execution_context>
@/Users/davidkwartler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidkwartler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-security-dashboard/06-RESEARCH.md

<interfaces>
<!-- Key types and contracts extracted from the codebase. No exploration required. -->

From prisma/schema.prisma — Session model (relevant fields):
```prisma
model Session {
  id           String           @id @default(cuid())
  sessionToken String           @unique
  userId       String
  expires      DateTime
  fingerprints    Fingerprint[]
  detectionEvents DetectionEvent[]
}

model Fingerprint {
  id         String   @id @default(cuid())
  sessionId  String
  visitorId  String
  ip         String?
  userAgent  String?  @db.Text
  isOriginal Boolean  @default(false)
  // other fields omitted
}

model DetectionEvent {
  id              String   @id @default(cuid())
  sessionId       String
  status          String   @default("PENDING")  // "PENDING" | "FLAGGED" | "CLEAR"
  confidenceScore Float?
  reasoning       String?  @db.Text
  createdAt       DateTime @default(now())
  // other fields omitted
}
```

From src/lib/db.ts:
```typescript
export const prisma: PrismaClient  // singleton — import as: import { prisma } from "@/lib/db"
```

From src/lib/auth.ts:
```typescript
export const { auth, signOut, signIn, handlers } = NextAuth(...)
// auth() returns session or null — import as: import { auth } from "@/lib/auth"
```

Status derivation logic (no schema change needed):
```typescript
// Each session row: take the most recent DetectionEvent.status
// If no DetectionEvent exists, status = "ACTIVE" (untouched session)
// Values written by claude.ts: "PENDING" | "FLAGGED" | "CLEAR"
const status = session.detectionEvents[0]?.status ?? "ACTIVE"
const isFlagged = status === "FLAGGED"
```

Prisma query shape for dashboard:
```typescript
const sessions = await prisma.session.findMany({
  where: { expires: { gt: new Date() } },   // non-expired sessions only
  include: {
    fingerprints: {
      where: { isOriginal: true },
      take: 1,
    },
    detectionEvents: {
      orderBy: { createdAt: "desc" },
      take: 1,   // most recent event only
    },
  },
  orderBy: { expires: "desc" },
})
```

Type alias for SessionTable props (derive from Prisma result shape):
```typescript
type SessionRow = Awaited<ReturnType<typeof prisma.session.findMany<{
  include: {
    fingerprints: { where: { isOriginal: boolean }; take: number }
    detectionEvents: { orderBy: { createdAt: "desc" }; take: number }
  }
}>>>[number]
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SessionTable client component with status badges and expandable reasoning panel</name>
  <files>src/components/SessionTable.tsx</files>
  <action>
Create src/components/SessionTable.tsx as a "use client" component. This is the interactive layer — it manages expanded row state with useState and renders all session data.

Write the full file with this exact structure:

```typescript
"use client"

import { useState } from "react"

type DetectionEventRow = {
  id: string
  status: string
  confidenceScore: number | null
  reasoning: string | null
}

type FingerprintRow = {
  visitorId: string
  ip: string | null
  userAgent: string | null
}

type SessionRow = {
  id: string
  detectionEvents: DetectionEventRow[]
  fingerprints: FingerprintRow[]
}

export function SessionTable({ sessions }: { sessions: SessionRow[] }) {
  const [expandedId, setExpandedId] = useState<string | null>(null)

  function toggle(id: string) {
    setExpandedId(prev => (prev === id ? null : id))
  }

  if (sessions.length === 0) {
    return (
      <div className="rounded-lg border border-gray-200 bg-white p-8 text-center text-sm text-gray-400 shadow-sm">
        No active sessions found.
      </div>
    )
  }

  return (
    <div className="overflow-hidden rounded-lg border border-gray-200 bg-white shadow-sm">
      <table className="w-full text-sm">
        <thead className="bg-gray-50 text-xs uppercase tracking-wide text-gray-500">
          <tr>
            <th className="px-4 py-3 text-left">Visitor ID</th>
            <th className="px-4 py-3 text-left">IP Address</th>
            <th className="px-4 py-3 text-left">User Agent</th>
            <th className="px-4 py-3 text-left">Status</th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-100">
          {sessions.map(session => {
            const fp = session.fingerprints[0]
            const event = session.detectionEvents[0]
            const status = event?.status ?? "ACTIVE"
            const isFlagged = status === "FLAGGED"
            const isExpanded = expandedId === session.id

            return (
              <SessionRowFragment
                key={session.id}
                sessionId={session.id}
                fp={fp}
                event={event ?? null}
                status={status}
                isFlagged={isFlagged}
                isExpanded={isExpanded}
                onToggle={toggle}
              />
            )
          })}
        </tbody>
      </table>
    </div>
  )
}

function SessionRowFragment({
  sessionId,
  fp,
  event,
  status,
  isFlagged,
  isExpanded,
  onToggle,
}: {
  sessionId: string
  fp: FingerprintRow | undefined
  event: DetectionEventRow | null
  status: string
  isFlagged: boolean
  isExpanded: boolean
  onToggle: (id: string) => void
}) {
  return (
    <>
      <tr
        onClick={() => isFlagged && onToggle(sessionId)}
        className={isFlagged ? "cursor-pointer hover:bg-red-50" : ""}
        title={isFlagged ? "Click to view Claude's reasoning" : undefined}
      >
        <td className="px-4 py-3 font-mono text-xs text-gray-700">
          {fp?.visitorId ? fp.visitorId.slice(0, 12) + "…" : "—"}
        </td>
        <td className="px-4 py-3 text-gray-600">{fp?.ip ?? "—"}</td>
        <td className="max-w-xs truncate px-4 py-3 text-xs text-gray-500">
          {fp?.userAgent ?? "—"}
        </td>
        <td className="px-4 py-3">
          <StatusBadge status={status} />
        </td>
      </tr>
      {isFlagged && isExpanded && event && (
        <tr>
          <td
            colSpan={4}
            className="border-t border-red-100 bg-red-50 px-4 py-4"
          >
            <p className="mb-2 text-xs font-semibold text-red-700">
              Confidence Score: {event.confidenceScore ?? "—"} / 100
            </p>
            <p className="text-sm leading-relaxed text-gray-700">
              {event.reasoning ?? "No reasoning available."}
            </p>
          </td>
        </tr>
      )}
    </>
  )
}

function StatusBadge({ status }: { status: string }) {
  const styles: Record<string, string> = {
    FLAGGED: "bg-red-100 text-red-700",
    PENDING: "bg-yellow-100 text-yellow-700",
    CLEAR:   "bg-green-100 text-green-700",
    ACTIVE:  "bg-gray-100 text-gray-600",
  }
  const cls = styles[status] ?? styles.ACTIVE
  return (
    <span className={`inline-flex rounded-full px-2 py-0.5 text-xs font-medium ${cls}`}>
      {status}
    </span>
  )
}
```

Implementation notes:
- The fragment rows are extracted into a named `SessionRowFragment` sub-component to avoid React key warnings on `<>` fragments inside `{sessions.map(...)}`. Each sub-component renders exactly two `<tr>` elements — the data row and the optional detail row — with React correctly tracking keys via the parent `key={session.id}` on `<SessionRowFragment>`.
- `isFlagged && isExpanded && event &&` triple guard ensures the detail row only renders when: status is FLAGGED, the row is toggled open, and a detection event exists.
- The `title` attribute on the flagged `<tr>` provides a hover tooltip telling users they can click to expand — no separate affordance needed at this scope.
- Do NOT import any third-party table library — Tailwind HTML table is sufficient and matches project style.
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - src/components/SessionTable.tsx exists with "use client" directive at the top
    - Exports `SessionTable` function accepting `{ sessions: SessionRow[] }`
    - Contains `StatusBadge` sub-component with FLAGGED/PENDING/CLEAR/ACTIVE Tailwind styles
    - Contains expandable detail row rendering `confidenceScore` and `reasoning` for FLAGGED rows
    - `npx tsc --noEmit` exits 0 with no errors referencing SessionTable.tsx
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dashboard page, PollingRefresher, and add Dashboard nav link</name>
  <files>
    src/app/(shop)/dashboard/page.tsx,
    src/app/(shop)/dashboard/PollingRefresher.tsx,
    src/app/(shop)/layout.tsx
  </files>
  <action>
Create two new files and update one existing file.

**File 1: src/app/(shop)/dashboard/PollingRefresher.tsx**

```typescript
"use client"

import { useEffect } from "react"
import { useRouter } from "next/navigation"

export function PollingRefresher({ intervalMs }: { intervalMs: number }) {
  const router = useRouter()

  useEffect(() => {
    const id = setInterval(() => {
      router.refresh()
    }, intervalMs)
    return () => clearInterval(id)
  }, [intervalMs, router])

  return null
}
```

Critical: `useRouter` MUST be imported from `"next/navigation"` — NOT `"next/router"`. The App Router uses `next/navigation`. Importing from `next/router` causes a runtime error.
The `intervalMs` is set to `8000` at the call site in page.tsx — this leaves 2 seconds of headroom under the 10-second success criterion.
The `useEffect` cleanup `() => clearInterval(id)` is mandatory — prevents memory leaks when the user navigates away from the dashboard.

---

**File 2: src/app/(shop)/dashboard/page.tsx**

```typescript
import { auth } from "@/lib/auth"
import { redirect } from "next/navigation"
import { prisma } from "@/lib/db"
import { SessionTable } from "@/components/SessionTable"
import { PollingRefresher } from "./PollingRefresher"

export default async function DashboardPage() {
  const session = await auth()
  if (!session) redirect("/login")

  const sessions = await prisma.session.findMany({
    where: { expires: { gt: new Date() } },
    include: {
      fingerprints: {
        where: { isOriginal: true },
        take: 1,
      },
      detectionEvents: {
        orderBy: { createdAt: "desc" },
        take: 1,
      },
    },
    orderBy: { expires: "desc" },
  })

  return (
    <div>
      <PollingRefresher intervalMs={8000} />
      <div className="mb-6 flex items-center justify-between">
        <h1 className="text-2xl font-semibold text-gray-900">
          Security Dashboard
        </h1>
        <p className="text-xs text-gray-400">
          Auto-refreshes every 8 seconds
        </p>
      </div>
      <SessionTable sessions={sessions} />
    </div>
  )
}
```

Implementation notes:
- `auth()` + `redirect("/login")` is the dual-layer auth protection pattern — identical to `(shop)/layout.tsx`. The middleware (proxy.ts) already covers `/dashboard` with its matcher, but a server-side redirect is the established project pattern for belt-and-suspenders protection.
- Direct Prisma call (no `fetch()`) bypasses Next.js router cache — every `router.refresh()` call hits the database and returns fresh data. Do NOT wrap the Prisma call in `fetch()`.
- `where: { expires: { gt: new Date() } }` filters to non-expired sessions only — prevents the table from filling with historical Auth.js session rows from past logins.
- `fingerprints: { where: { isOriginal: true }, take: 1 }` — only the original fingerprint is needed; non-original fingerprints are the hijack fingerprints and are represented via the DetectionEvent.
- `detectionEvents: { orderBy: { createdAt: "desc" }, take: 1 }` — only the most recent detection event per session is used for display.
- The page lives at `(shop)/dashboard/` so it inherits the shop layout (shared nav, `<main>` wrapper, FingerprintReporter). No separate layout.tsx is needed.

---

**File 3: src/app/(shop)/layout.tsx — add Dashboard link**

In the existing nav, find the Links section (Products and Profile links) and add a Dashboard link after the Profile link:

Locate this block in src/app/(shop)/layout.tsx:
```typescript
            <Link
              href="/profile"
              className="text-sm text-gray-600 hover:text-gray-900"
            >
              Profile
            </Link>
```

Add the Dashboard link immediately after it:
```typescript
            <Link
              href="/dashboard"
              className="text-sm text-gray-600 hover:text-gray-900"
            >
              Dashboard
            </Link>
```

Do NOT modify any other part of layout.tsx — only add the single Link element.
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - src/app/(shop)/dashboard/page.tsx exists as an async Server Component with auth check, Prisma findMany, and renders SessionTable + PollingRefresher
    - src/app/(shop)/dashboard/PollingRefresher.tsx exists with "use client" directive, imports useRouter from "next/navigation", calls router.refresh() every intervalMs
    - src/app/(shop)/layout.tsx contains a Link to "/dashboard" in the nav
    - `npx tsc --noEmit` exits 0 — no TypeScript errors across all three files
    - `grep "next/navigation" src/app/(shop)/dashboard/PollingRefresher.tsx` confirms correct import
    - `grep "prisma.session.findMany" src/app/(shop)/dashboard/page.tsx` returns a match
    - `grep "/dashboard" src/app/(shop)/layout.tsx` returns a match
  </done>
</task>

</tasks>

<verification>
Run these checks after both tasks complete:

```bash
# 1. TypeScript compiles clean across the whole project
cd /Users/davidkwartler/sentinel && npx tsc --noEmit 2>&1 | grep -c "error TS" || echo "0 TS errors"

# 2. SessionTable exists with "use client" and exports
grep -n "use client\|export function SessionTable\|StatusBadge\|FLAGGED" /Users/davidkwartler/sentinel/src/components/SessionTable.tsx

# 3. Dashboard page exists and has auth + Prisma query
grep -n "auth()\|redirect\|prisma.session.findMany\|PollingRefresher\|SessionTable" /Users/davidkwartler/sentinel/src/app/\(shop\)/dashboard/page.tsx

# 4. PollingRefresher uses correct import
grep -n "next/navigation\|router.refresh\|clearInterval" /Users/davidkwartler/sentinel/src/app/\(shop\)/dashboard/PollingRefresher.tsx

# 5. Dashboard nav link added
grep -n "dashboard" /Users/davidkwartler/sentinel/src/app/\(shop\)/layout.tsx

# 6. Build check (catches runtime errors TypeScript misses)
cd /Users/davidkwartler/sentinel && npm run build 2>&1 | tail -20
```
</verification>

<success_criteria>
1. `npx tsc --noEmit` exits 0 — no TypeScript errors introduced by any of the three new/modified files
2. `npm run build` completes without errors
3. src/components/SessionTable.tsx exports `SessionTable` with color-coded status badges (ACTIVE/PENDING/FLAGGED/CLEAR) and a click-to-expand detail panel for FLAGGED rows showing `confidenceScore` and `reasoning`
4. src/app/(shop)/dashboard/page.tsx performs server-side auth check, queries Prisma for non-expired sessions with original fingerprints and most-recent detection events, and renders both SessionTable and PollingRefresher
5. src/app/(shop)/dashboard/PollingRefresher.tsx calls `router.refresh()` every 8 seconds with proper cleanup
6. The Dashboard nav link appears in the shop nav bar
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-dashboard/06-01-SUMMARY.md` documenting:
- Files created and their line counts
- Any deviations from this plan (e.g., TypeScript type shape adjustments needed)
- Build output (pass/fail)
- Whether the `router.refresh()` correct import was confirmed
</output>
