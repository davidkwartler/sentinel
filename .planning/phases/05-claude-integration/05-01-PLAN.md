---
phase: 05-claude-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/claude.ts
autonomous: true
requirements:
  - AI-02
  - AI-03

must_haves:
  truths:
    - "DetectionEvent rows have nullable confidenceScore and reasoning columns (migration applied)"
    - "analyzeDetectionEvent(eventId) calls Claude with a structured output schema and writes score + reasoning back to the row"
    - "The Claude model used is read from ANTHROPIC_MODEL env var — swapping the env var changes the model with no code edits"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "DetectionEvent model with confidenceScore Float? and reasoning String? @db.Text"
      contains: "confidenceScore"
    - path: "src/lib/claude.ts"
      provides: "Anthropic client singleton + analyzeDetectionEvent() function"
      exports: ["analyzeDetectionEvent"]
    - path: "prisma/migrations"
      provides: "Applied migration adding the two nullable columns"
  key_links:
    - from: "src/lib/claude.ts"
      to: "prisma.detectionEvent"
      via: "prisma.detectionEvent.findUnique then prisma.detectionEvent.update"
      pattern: "prisma\\.detectionEvent\\.(findUnique|update)"
    - from: "src/lib/claude.ts"
      to: "process.env.ANTHROPIC_MODEL"
      via: "model constant read before messages.create call"
      pattern: "ANTHROPIC_MODEL"
---

<objective>
Add the two new columns that Claude analysis needs and create the analyzeDetectionEvent() function that calls the Anthropic API with structured outputs.

Purpose: This plan lays the data and library foundation for async Claude analysis. Plan 05-02 will wire this into the route handler. Splitting ensures the migration and SDK work are isolated from the HTTP-layer changes.
Output: prisma/schema.prisma updated + migration applied; src/lib/claude.ts exporting analyzeDetectionEvent().
</objective>

<execution_context>
@/Users/davidkwartler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidkwartler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-claude-integration/05-RESEARCH.md

<interfaces>
<!-- Key existing types and exports the executor needs. No codebase exploration required. -->

From src/lib/db.ts:
```typescript
import { PrismaClient } from "@/generated/prisma/client"
import { PrismaPg } from "@prisma/adapter-pg"
export const prisma: PrismaClient  // singleton, already available
```

From src/lib/detection.ts:
```typescript
export interface DetectionResult {
  detected: boolean
  eventId?: string
}
```

Current DetectionEvent model in prisma/schema.prisma:
```prisma
model DetectionEvent {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  sessionId         String
  originalVisitorId String
  newVisitorId      String
  originalIp        String?
  newIp             String?
  similarityScore   Float
  status            String   @default("PENDING")
  session           Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}
```
Two columns are MISSING from this model: confidenceScore and reasoning.
They must be added as nullable to avoid breaking existing PENDING rows.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate schema — add confidenceScore and reasoning to DetectionEvent</name>
  <files>prisma/schema.prisma</files>
  <action>
Add two nullable columns to the DetectionEvent model in prisma/schema.prisma. Insert them AFTER the `status` field and BEFORE the `session` relation line:

```prisma
  confidenceScore   Float?   // null until Claude responds
  reasoning         String?  @db.Text  // null until Claude responds
```

The `@db.Text` directive on reasoning is required — Claude reasoning strings can exceed varchar limits; Text maps to PostgreSQL unbounded text, consistent with how `refresh_token`, `access_token`, `id_token`, and `userAgent` are stored in this schema.

After editing the schema, run the migration:
```bash
cd /Users/davidkwartler/sentinel
npx prisma migrate dev --name add-claude-fields-to-detection-event
```

Then regenerate the Prisma client so TypeScript picks up the new fields:
```bash
npx prisma generate
```

Do NOT use `prisma db push` — this project uses `migrate dev` for tracked migrations (consistent with how Phase 4 applied the DetectionEvent model).
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npx prisma validate && echo "Schema valid"</automated>
  </verify>
  <done>
    - prisma/schema.prisma contains `confidenceScore   Float?` and `reasoning         String?  @db.Text` inside the DetectionEvent model
    - A migration file exists under prisma/migrations/ named *add-claude-fields-to-detection-event/migration.sql
    - `npx prisma validate` exits 0
    - `npx prisma generate` completes without errors (Prisma client regenerated with new types)
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Create src/lib/claude.ts — Anthropic client singleton and analyzeDetectionEvent()</name>
  <files>src/lib/claude.ts</files>
  <behavior>
    - analyzeDetectionEvent(nonExistentId) returns early without throwing (event not found guard)
    - analyzeDetectionEvent(validId) calls anthropic.messages.create with model = process.env.ANTHROPIC_MODEL ?? "claude-sonnet-4-6"
    - After Claude responds, DetectionEvent row is updated: confidenceScore set to parsed integer, reasoning set to string, status set to "FLAGGED" if confidenceScore >= 70 else "CLEAR"
    - If response.content[0].type !== "text", function throws an Error (type guard)
  </behavior>
  <action>
Install the Anthropic SDK first:
```bash
cd /Users/davidkwartler/sentinel && npm install @anthropic-ai/sdk
```

Create src/lib/claude.ts with this exact structure:

```typescript
import Anthropic from "@anthropic-ai/sdk"
import { prisma } from "@/lib/db"

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
})

export async function analyzeDetectionEvent(eventId: string): Promise<void> {
  const event = await prisma.detectionEvent.findUnique({ where: { id: eventId } })
  if (!event) return

  const model = process.env.ANTHROPIC_MODEL ?? "claude-sonnet-4-6"

  const response = await anthropic.messages.create({
    model,
    max_tokens: 512,
    system:
      "You are a security analysis system. Given two browser fingerprints from the same session, " +
      "determine the likelihood that the second access is a session hijack attempt. " +
      "Return a confidence score from 0 (definitely legitimate) to 100 (definitely a hijack).",
    messages: [
      {
        role: "user",
        content:
          `Session ID: ${event.sessionId}\n` +
          `Original visitor ID: ${event.originalVisitorId} (IP: ${event.originalIp ?? "unknown"})\n` +
          `New visitor ID: ${event.newVisitorId} (IP: ${event.newIp ?? "unknown"})\n` +
          `Component similarity score: ${event.similarityScore.toFixed(2)} (0=different, 1=identical)\n\n` +
          "Analyze whether this represents a session hijack.",
      },
    ],
    output_config: {
      format: {
        type: "json_schema",
        schema: {
          type: "object",
          properties: {
            confidenceScore: {
              type: "integer",
              minimum: 0,
              maximum: 100,
              description: "0 = definitely not a hijack, 100 = definitely a hijack",
            },
            reasoning: {
              type: "string",
              description: "Human-readable explanation of the confidence score",
            },
          },
          required: ["confidenceScore", "reasoning"],
          additionalProperties: false,
        },
      },
    },
  })

  if (response.content[0].type !== "text") {
    throw new Error(`Unexpected Claude response type: ${response.content[0].type}`)
  }

  const result = JSON.parse(response.content[0].text) as {
    confidenceScore: number
    reasoning: string
  }

  await prisma.detectionEvent.update({
    where: { id: eventId },
    data: {
      confidenceScore: result.confidenceScore,
      reasoning: result.reasoning,
      status: result.confidenceScore >= 70 ? "FLAGGED" : "CLEAR",
    },
  })
}
```

Key implementation notes:
- The `anthropic` client is a module-level singleton (NOT inside the function) — prevents new HTTP client per invocation.
- `output_config.format` with `type: "json_schema"` is the GA structured outputs API (no beta header needed). This guarantees schema-compliant JSON — no retry logic required.
- `process.env.ANTHROPIC_MODEL ?? "claude-sonnet-4-6"` is read inside the function body (not at module load time) so runtime env var changes are picked up without a redeploy. This satisfies AI-03.
- `FLAGGED` threshold is 70 — hardcoded for Phase 5. Phase 6 will make this configurable.
- Do NOT use `response_format: {type: "json"}` (old beta approach) or the `anthropic-beta: structured-outputs-2025-11-13` header (no longer needed).
- Do NOT fire-and-forget without `after()` — that is handled in Plan 05-02. This file just exports the function.
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - src/lib/claude.ts exists and exports `analyzeDetectionEvent`
    - `npx tsc --noEmit` passes with no errors related to claude.ts or the updated DetectionEvent types
    - The function reads `process.env.ANTHROPIC_MODEL` (grep confirms: `grep "ANTHROPIC_MODEL" src/lib/claude.ts` returns a match)
    - The function uses `output_config.format` structured outputs (grep confirms: `grep "output_config" src/lib/claude.ts` returns a match)
    - `npm install @anthropic-ai/sdk` completed and `@anthropic-ai/sdk` appears in package.json dependencies
  </done>
</task>

</tasks>

<verification>
Run these checks after both tasks complete:

```bash
# 1. Schema validates and contains new fields
cd /Users/davidkwartler/sentinel && npx prisma validate

# 2. New columns visible in generated client types
grep -n "confidenceScore\|reasoning" src/generated/prisma/client/index.d.ts | head -10

# 3. Migration SQL contains the two ALTER TABLE statements
cat prisma/migrations/*add-claude-fields-to-detection-event/migration.sql

# 4. TypeScript compiles clean
npx tsc --noEmit 2>&1 | grep -c "error" || echo "0 errors"

# 5. SDK installed
grep "@anthropic-ai/sdk" package.json

# 6. analyzeDetectionEvent exported
grep "export async function analyzeDetectionEvent" src/lib/claude.ts

# 7. AI-03 satisfied — model read from env
grep "ANTHROPIC_MODEL" src/lib/claude.ts
```
</verification>

<success_criteria>
1. `npx prisma validate` exits 0 with no warnings about DetectionEvent
2. Migration file exists under prisma/migrations/ with SQL adding confidenceScore and reasoning columns as NULLABLE
3. src/lib/claude.ts exports `analyzeDetectionEvent(eventId: string): Promise<void>`
4. The function uses `process.env.ANTHROPIC_MODEL ?? "claude-sonnet-4-6"` — swapping the env var changes the model, satisfying AI-03
5. The function uses `output_config.format.type = "json_schema"` for guaranteed structured output, satisfying AI-02's requirement for reliable confidenceScore + reasoning
6. `npx tsc --noEmit` exits 0 — no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-claude-integration/05-01-SUMMARY.md` documenting:
- Migration name and columns added
- analyzeDetectionEvent() signature and threshold used (>= 70 = FLAGGED)
- SDK version installed
- Any deviations from this plan
</output>
