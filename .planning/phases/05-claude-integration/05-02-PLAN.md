---
phase: 05-claude-integration
plan: 02
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified:
  - src/app/api/session/record/route.ts
autonomous: false
requirements:
  - AI-01

must_haves:
  truths:
    - "After simulating a hijack, the /api/session/record POST response returns in under 1 second with detected: true and a PENDING eventId — Claude has NOT finished yet"
    - "Seconds later (out-of-band), the DetectionEvent row is updated with a numeric confidenceScore and non-empty reasoning string, and status changes from PENDING to FLAGGED or CLEAR"
    - "A second ingest from the same browser (same visitorId) does NOT trigger a Claude call"
  artifacts:
    - path: "src/app/api/session/record/route.ts"
      provides: "after() dispatch integrated into the POST handler"
      contains: "after"
  key_links:
    - from: "src/app/api/session/record/route.ts"
      to: "src/lib/claude.ts"
      via: "after(() => analyzeDetectionEvent(eventId)) called before return"
      pattern: "analyzeDetectionEvent"
    - from: "after() callback"
      to: "prisma.detectionEvent"
      via: "analyzeDetectionEvent updates row after Claude responds"
      pattern: "after\\("
---

<objective>
Wire the analyzeDetectionEvent() function into the fingerprint ingest route handler using next/server after(), so Claude is called asynchronously after the HTTP response is sent.

Purpose: This is the final wiring step that makes the HTTP response non-blocking (AI-01). The library and schema already exist from Plan 05-01. This plan adds exactly two import lines and one after() block to the route handler, then verifies the end-to-end async behavior with a human-driven hijack simulation.
Output: Updated src/app/api/session/record/route.ts with after() dispatch; verified end-to-end async analysis.
</objective>

<execution_context>
@/Users/davidkwartler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidkwartler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-claude-integration/05-RESEARCH.md
@.planning/phases/05-claude-integration/05-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. No codebase exploration required. -->

From src/lib/claude.ts (created in Plan 05-01):
```typescript
export async function analyzeDetectionEvent(eventId: string): Promise<void>
// Calls Anthropic API, updates DetectionEvent row with confidenceScore, reasoning, and status (FLAGGED|CLEAR)
// Returns void — fire-and-forget semantics; errors are caught internally
```

Current src/app/api/session/record/route.ts structure (key section):
```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { prisma } from "@/lib/db"
import { z } from "zod"
import { runDetection } from "@/lib/detection"

// ... schema, auth, dedup, fingerprint persist logic ...

  // Run detection: compare new fingerprint against session's original
  const detectionResult = await runDetection({
    sessionId: dbSession.id,
    newVisitorId: data.visitorId,
    newIp: ip,
    os: data.os ?? null,
    browser: data.browser ?? null,
    screenRes: data.screenRes ?? null,
    timezone: data.timezone ?? null,
  })

  return NextResponse.json({
    status: "ok",
    id: fingerprint.id,
    detected: detectionResult.detected,
    eventId: detectionResult.eventId ?? null,
  })
```

The after() block must be inserted BETWEEN the runDetection() call and the return statement.

From next/server (Next.js 16.1.6 — built-in, no install needed):
```typescript
import { after } from "next/server"
// after(callback) — schedules callback to run after HTTP response is sent
// Integrates with Vercel waitUntil automatically
// callback MUST be async; eventId MUST be captured as a local const before the callback (closure pitfall)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire after() dispatch into the fingerprint ingest route handler</name>
  <files>src/app/api/session/record/route.ts</files>
  <action>
Make exactly these two changes to src/app/api/session/record/route.ts:

**Change 1 — Add imports at the top of the file** (add two lines after the existing imports):
```typescript
import { after } from "next/server"
import { analyzeDetectionEvent } from "@/lib/claude"
```

**Change 2 — Add after() block** between the runDetection() result and the return statement:
```typescript
  // Dispatch async Claude analysis if a hijack was detected
  if (detectionResult.detected && detectionResult.eventId) {
    const eventId = detectionResult.eventId  // capture primitive before async boundary
    after(async () => {
      try {
        await analyzeDetectionEvent(eventId)
      } catch (err) {
        console.error("[claude] analyzeDetectionEvent failed for event", eventId, err)
        // Leave status as PENDING on error — Phase 6 dashboard shows PENDING as unresolved
      }
    })
  }

  return NextResponse.json({
    status: "ok",
    id: fingerprint.id,
    detected: detectionResult.detected,
    eventId: detectionResult.eventId ?? null,
  })
```

Critical implementation rules:
- The `const eventId = detectionResult.eventId` capture BEFORE the `after()` callback is mandatory — closures capture references, and `detectionResult` could theoretically be reassigned. Capturing the primitive string prevents stale closure bugs.
- The `after()` callback wraps the call in try/catch and logs on error — leaves status as PENDING rather than crashing. This satisfies the Phase 5 open question: on failure, row stays PENDING (v2 UNKNOWN state is deferred per STATE.md).
- Do NOT `await analyzeDetectionEvent(...)` directly in the route handler body — that would block the response and violate AI-01.
- Do NOT use fire-and-forget `analyzeDetectionEvent(eventId).catch(console.error)` without `after()` — the Vercel serverless function may terminate before the promise resolves.
- The `after` import comes from `"next/server"` (built-in since Next.js 15.1.0) — do NOT install any additional package.
  </action>
  <verify>
    <automated>cd /Users/davidkwartler/sentinel && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - src/app/api/session/record/route.ts imports `after` from `"next/server"` and `analyzeDetectionEvent` from `"@/lib/claude"`
    - An `after()` block exists in the POST handler, triggered only when `detectionResult.detected && detectionResult.eventId` is true
    - The `eventId` is captured as a local const before the callback
    - The callback wraps `analyzeDetectionEvent` in try/catch
    - `npx tsc --noEmit` exits 0 — no TypeScript errors
    - `grep "after(" src/app/api/session/record/route.ts` returns a match
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Full async Claude integration: after() dispatch in the route handler (Task 1) + analyzeDetectionEvent() library (Plan 05-01) + schema migration adding confidenceScore and reasoning columns.

    The complete flow:
    1. Authenticated browser sends a fingerprint POST to /api/session/record
    2. If visitorId differs from the session's original, runDetection() creates a PENDING DetectionEvent
    3. after() schedules analyzeDetectionEvent(eventId) to run after the response is sent
    4. Response returns immediately with { detected: true, eventId: "..." }
    5. Out-of-band: Claude is called, returns structured JSON, DetectionEvent is updated with confidenceScore + reasoning + status (FLAGGED or CLEAR)
  </what-built>
  <how-to-verify>
    **Prerequisites:** Dev server running (`npm run dev` in a separate terminal from the project root).

    **Step 1 — Start the dev server:**
    ```
    cd /Users/davidkwartler/sentinel && npm run dev
    ```

    **Step 2 — Sign in and get a baseline fingerprint:**
    - Open http://localhost:3000 in Browser A (your normal browser)
    - Sign in with Google and navigate to /products
    - Open DevTools → Application → Cookies → find the `auth_session` cookie → copy its full value

    **Step 3 — Simulate a hijack (same session, different visitorId):**
    - Open a different browser (e.g., Firefox or a Chrome Incognito window) — this is "Browser B"
    - In Browser B DevTools → Application → Cookies → manually set a cookie named `auth_session` with the value copied from Browser A
    - Navigate to http://localhost:3000/products in Browser B
    - FingerprintJS will generate a different visitorId for Browser B — this simulates the stolen cookie scenario

    **Step 4 — Verify response speed (AI-01):**
    - In Browser B DevTools → Network tab → find the POST to `/api/session/record`
    - Confirm the response time is under 1000ms
    - Confirm the response body contains: `{ "status": "ok", "detected": true, "eventId": "<some-id>" }`
    - If `detected` is false, the hijack simulation did not produce a new visitorId — try a truly different browser

    **Step 5 — Verify async Claude update (AI-02):**
    - Wait 5–15 seconds after the POST completes
    - Query the database directly to confirm the DetectionEvent row was updated:
      ```bash
      cd /Users/davidkwartler/sentinel
      npx prisma studio
      ```
      Open Prisma Studio → DetectionEvent table → find the row with the eventId from Step 4
      Confirm: `confidenceScore` is a number (0–100), `reasoning` is a non-empty string, `status` is "FLAGGED" or "CLEAR" (not "PENDING")

    **Step 6 — Verify model configurability (AI-03):**
    - Confirm `ANTHROPIC_MODEL` env var is set in .env.local (or that the default "claude-sonnet-4-6" was used if it's absent)
    - This can be verified from the Anthropic API dashboard or function logs showing the model name

    **Expected outcomes:**
    - Response under 1s with `detected: true` and a non-null `eventId` ✓
    - DetectionEvent row shows numeric `confidenceScore` and non-empty `reasoning` within ~15s ✓
    - Status is "FLAGGED" (if score >= 70) or "CLEAR" (if score < 70) ✓
  </how-to-verify>
  <resume-signal>Type "approved" if all three success criteria are confirmed, or describe what failed (e.g., "response was slow", "row stayed PENDING", "detected was false")</resume-signal>
</task>

</tasks>

<verification>
End-to-end verification commands (run before triggering the checkpoint):

```bash
# 1. after() is present in the route handler
grep -n "after(" /Users/davidkwartler/sentinel/src/app/api/session/record/route.ts

# 2. analyzeDetectionEvent is imported in the route handler
grep -n "analyzeDetectionEvent" /Users/davidkwartler/sentinel/src/app/api/session/record/route.ts

# 3. TypeScript compiles clean across all modified files
cd /Users/davidkwartler/sentinel && npx tsc --noEmit 2>&1 | grep -c "error" || echo "0 errors"

# 4. All three AI requirements have implementation files
echo "AI-01: after() in route" && grep -c "after(" /Users/davidkwartler/sentinel/src/app/api/session/record/route.ts
echo "AI-02: output_config in claude.ts" && grep -c "output_config" /Users/davidkwartler/sentinel/src/lib/claude.ts
echo "AI-03: ANTHROPIC_MODEL in claude.ts" && grep -c "ANTHROPIC_MODEL" /Users/davidkwartler/sentinel/src/lib/claude.ts
```
</verification>

<success_criteria>
1. POST to /api/session/record with a mismatched visitorId returns in under 1 second with `detected: true` and a non-null `eventId` — response does NOT wait for Claude (AI-01)
2. After Claude completes (within ~15 seconds), the DetectionEvent row has a numeric `confidenceScore` (0–100), a non-empty `reasoning` string, and status "FLAGGED" or "CLEAR" (AI-02)
3. The model used is read from `ANTHROPIC_MODEL` env var — changing the env var changes which model is called without any code edits (AI-03)
4. A second request from the same browser (same visitorId) does NOT trigger a new detection event or a Claude call
5. `npx tsc --noEmit` exits 0 across the entire project
</success_criteria>

<output>
After completion, create `.planning/phases/05-claude-integration/05-02-SUMMARY.md` documenting:
- The exact diff applied to record/route.ts (import lines + after() block)
- Hijack simulation result: response time observed, eventId received, confidenceScore and reasoning values seen
- Any issues encountered during verification
</output>
